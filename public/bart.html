<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Brat-Bart Sticker Maker (Offline)</title>
<!-- optional: load Roboto from Google (works offline if host has it; fallback to system fonts) -->
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --ui-bg:#f3f4f6;
    --card-bg:#ffffff;
    --accent:#111827;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: 'Roboto', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:var(--ui-bg);
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:100vh;
    padding:20px;
    color:#111;
  }

  .wrap{
    width:100%;
    max-width:980px;
    display:grid;
    grid-template-columns: 1fr 380px;
    gap:18px;
    align-items:start;
  }

  .card{
    background:var(--card-bg);
    border-radius:12px;
    padding:16px;
    box-shadow:0 8px 30px rgba(0,0,0,0.07);
  }

  .controls{
    display:flex;
    flex-direction:column;
    gap:10px;
  }

  label{font-size:13px;color:#374151}
  textarea{width:100%;min-height:140px;padding:10px;border-radius:8px;border:1px solid #e5e7eb;font-size:15px;resize:vertical}
  .row{display:flex;gap:8px;align-items:center}
  input[type="color"]{width:48px;height:42px;padding:4px;border-radius:8px;border:1px solid #e5e7eb}
  input[type="number"]{width:100%;padding:8px;border-radius:8px;border:1px solid #e5e7eb}
  select{padding:8px;border-radius:8px;border:1px solid #e5e7eb}
  button{background:var(--accent);color:white;padding:10px 12px;border-radius:8px;border:0;cursor:pointer}
  .muted{font-size:13px;color:#6b7280}
  canvas{display:block;border-radius:6px;background:transparent; width:100%; height:auto; max-width:512px; margin:8px auto}

  /* responsive */
  @media(max-width:950px){
    .wrap{grid-template-columns: 1fr}
  }

  /* small helpers */
  .inline{display:flex;gap:8px;align-items:center}
  .flex{display:flex;gap:8px}
  .center{justify-content:center;align-items:center}
</style>
</head>
<body>
  <div class="wrap">
    <!-- Left: main UI -->
    <div class="card">
      <h2 style="margin:0 0 8px">Brat-Bart Sticker Maker (Offline)</h2>
      <div class="controls">
        <div>
          <label>Masukkan teks (multi-baris OK):</label>
          <textarea id="textInput" placeholder="Ketik teks...">brat</textarea>
        </div>

        <div class="row">
          <div style="flex:1">
            <label>Warna teks:</label>
            <div class="inline">
              <input id="colorInput" type="color" value="#000000">
              <div style="flex:1;margin-left:6px">
                <select id="fontSelect" title="Font">
                  <option value="Roboto">Roboto (default)</option>
                  <option value="Arial">Arial</option>
                  <option value="Helvetica">Helvetica</option>
                  <option value="Impact">Impact</option>
                  <option value="Verdana">Verdana</option>
                </select>
              </div>
            </div>
          </div>

          <div style="width:140px">
            <label>Ukuran canvas (px)</label>
            <input id="canvasSize" type="number" min="128" max="2048" value="512">
          </div>
        </div>

        <div class="row">
          <div style="flex:1">
            <label>Background:</label>
            <div class="flex">
              <select id="bgMode">
                <option value="white">Putih</option>
                <option value="color">Warna</option>
                <option value="transparent">Transparan</option>
              </select>
              <input id="bgColor" type="color" value="#B8E000" title="Background color" />
            </div>
            <div class="muted" style="margin-top:6px">Pilih transparan kalau mau background non-kotak.</div>
          </div>

          <div style="width:140px">
            <label>Right padding (px)</label>
            <input id="rightPad" type="number" min="4" max="200" value="30">
          </div>
        </div>

        <div class="row">
          <div style="flex:1">
            <label>Blur intensity (0 = no blur)</label>
            <input id="blurRadius" type="number" min="0" max="50" value="2">
          </div>

          <div style="width:140px">
            <label>Font weight</label>
            <select id="fontWeight">
              <option value="700">Bold</option>
              <option value="400">Regular</option>
            </select>
          </div>
        </div>

        <div class="row">
          <button id="renderBtn">Render Preview</button>
          <button id="downloadPng">Download PNG</button>
          <button id="downloadWebp">Download WEBP</button>
        </div>

        <div class="muted">Tip: untuk stiker WA, ukuran 512×512 & background putih / transparan direkomendasikan.</div>
      </div>
    </div>

    <!-- Right: preview -->
    <div class="card center" style="padding:16px">
      <label style="font-size:13px">Preview (klik Render setelah ubah)</label>
      <canvas id="preview" width="512" height="512" aria-label="preview canvas"></canvas>
      <div class="muted" style="margin-top:8px;text-align:center">Output adalah gambar kotak. Kalau pilih "Transparan", latar tidak akan diisi.</div>
    </div>
  </div>

<script>
/* --- Utilities & DOM --- */
const preview = document.getElementById('preview');
const ctx = preview.getContext('2d');

const textInput = document.getElementById('textInput');
const colorInput = document.getElementById('colorInput');
const bgMode = document.getElementById('bgMode');
const bgColor = document.getElementById('bgColor');
const canvasSizeInput = document.getElementById('canvasSize');
const rightPadInput = document.getElementById('rightPad');
const blurRadiusInput = document.getElementById('blurRadius');
const renderBtn = document.getElementById('renderBtn');
const downloadPng = document.getElementById('downloadPng');
const downloadWebp = document.getElementById('downloadWebp');
const fontSelect = document.getElementById('fontSelect');
const fontWeight = document.getElementById('fontWeight');

function setCanvasSize(px) {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  preview.style.width = px + 'px';
  preview.style.height = px + 'px';
  preview.width = Math.round(px * dpr);
  preview.height = Math.round(px * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

/* wrap text into lines that fit a maxWidth (right-aligned) */
function wrapTextToLines(context, text, maxWidth) {
  const lines = [];
  // preserve explicit newlines: we'll treat each paragraph separately
  const paragraphs = text.split('\n');
  for (let p of paragraphs) {
    p = p.trim();
    if (p === '') {
      lines.push(''); // empty line
      continue;
    }
    const words = p.split(/\s+/);
    let line = words[0] || '';
    for (let i = 1; i < words.length; i++) {
      const test = line + ' ' + words[i];
      const m = context.measureText(test).width;
      if (m > maxWidth && line) {
        lines.push(line);
        line = words[i];
      } else {
        line = test;
      }
    }
    if (line) lines.push(line);
  }
  return lines;
}

/* main render function */
function renderSticker() {
  const canvasPx = parseInt(canvasSizeInput.value, 10) || 512;
  setCanvasSize(canvasPx);

  // settings
  const rawText = String(textInput.value || '');
  const textColor = colorInput.value || '#000';
  const bgModeVal = bgMode.value;
  const bgClr = bgColor.value || '#ffffff';
  const rightPad = Math.max(4, parseInt(rightPadInput.value, 10) || 30);
  const blur = Math.max(0, parseFloat(blurRadiusInput.value) || 0);
  const selectedFont = fontSelect.value || 'Roboto';
  const weight = fontWeight.value || '700';

  // clear / background
  if (bgModeVal === 'transparent') {
    // clear (transparent)
    ctx.clearRect(0, 0, canvasPx, canvasPx);
  } else {
    ctx.fillStyle = (bgModeVal === 'white') ? '#ffffff' : bgClr;
    ctx.fillRect(0, 0, canvasPx, canvasPx);
  }

  // prepare font sizing algorithm:
  // start large and shrink until fits both width and height
  const paddingHorizontal = Math.max(12, Math.floor(canvasPx * 0.04));
  const availableWidth = canvasPx - (paddingHorizontal + rightPad); // width for text (from left to x-rightPad)
  const availableHeight = canvasPx - paddingHorizontal * 2;

  // initial font size guess relative to canvas
  let fontSize = Math.round(canvasPx * 0.28); // heuristic (big for 1 word)
  ctx.textBaseline = 'middle';
  ctx.textAlign = 'right';

  // function to compute lines for a fontSize
  function computeLinesForSize(size) {
    ctx.font = `${weight} ${size}px ${selectedFont}, system-ui, Arial`;
    return wrapTextToLines(ctx, rawText, availableWidth);
  }

  let lines = computeLinesForSize(fontSize);
  const lineHeightFactor = 1.05 + (fontSize / 1000); // slight adapt

  // shrink loop until fits
  let attempts = 0;
  while ((lines.length * fontSize * lineHeightFactor > availableHeight || lines.some(l => ctx.measureText(l).width > availableWidth)) && attempts < 80) {
    fontSize = Math.max(8, Math.round(fontSize * 0.92));
    lines = computeLinesForSize(fontSize);
    attempts++;
  }

  // if still too tall, trim lines & ellipsize last
  const maxLines = Math.floor(availableHeight / (fontSize * lineHeightFactor));
  if (lines.length > maxLines) {
    lines = lines.slice(0, Math.max(1, maxLines));
    // ellipsize last line
    let last = lines[lines.length - 1];
    ctx.font = `${weight} ${fontSize}px ${selectedFont}, system-ui, Arial`;
    while (ctx.measureText(last + '…').width > availableWidth && last.length > 0) {
      last = last.slice(0, -1);
    }
    lines[lines.length - 1] = last + (last.length ? '…' : '');
  }

  // draw text with blur/shadow
  const x = canvasPx - rightPad; // right aligned x
  // shadow blur uses CSS pixels; scale slightly with font size
  ctx.fillStyle = textColor;
  ctx.font = `${weight} ${fontSize}px ${selectedFont}, system-ui, Arial`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  if (blur > 0) {
    ctx.shadowColor = textColor;
    // scale shadowBlur mildly with dpi/fontsize for consistent look
    ctx.shadowBlur = blur;
  } else {
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
  }

  // center vertically
  const totalHeight = lines.length * fontSize * lineHeightFactor;
  let startY = (canvasPx - totalHeight) / 2 + (fontSize * lineHeightFactor) / 2;

  // draw each line
  ctx.fillStyle = textColor;
  for (let i = 0; i < lines.length; i++) {
    const y = startY + i * fontSize * lineHeightFactor;
    ctx.fillText(lines[i], x, y);
  }
}

/* initial setup / events */
function safeRender() {
  try {
    renderSticker();
  } catch (e) {
    console.error(e);
  }
}

renderBtn.addEventListener('click', safeRender);
canvasSizeInput.addEventListener('change', safeRender);
bgMode.addEventListener('change', () => {
  bgColor.style.display = (bgMode.value === 'color') ? 'inline-block' : (bgMode.value === 'white' ? 'none' : 'none');
  // if transparent or white: hide color picker (but leave value)
  if (bgMode.value === 'color') bgColor.style.display = 'inline-block';
  else bgColor.style.display = 'none';
  safeRender();
});

// show/hide bg picker depending on default state
if (bgMode.value !== 'color') bgColor.style.display = 'none';

[ textInput, colorInput, bgColor, rightPadInput, blurRadiusInput, fontSelect, fontWeight ].forEach(el=>{
  el.addEventListener('input', () => {
    // debounce slight
    clearTimeout(window._rb);
    window._rb = setTimeout(safeRender, 110);
  });
});

downloadPng.addEventListener('click', () => {
  // produce PNG with current canvas content (has correct DPR)
  const mime = 'image/png';
  const data = preview.toDataURL(mime);
  const a = document.createElement('a');
  a.href = data;
  a.download = `bratbart-${canvasSizeInput.value}px.png`;
  document.body.appendChild(a);
  a.click();
  a.remove();
});

downloadWebp.addEventListener('click', () => {
  const mime = 'image/webp';
  // some browsers may not support webp canvas export; fallback handled by browser
  const data = preview.toDataURL(mime, 0.92);
  const a = document.createElement('a');
  a.href = data;
  a.download = `bratbart-${canvasSizeInput.value}px.webp`;
  document.body.appendChild(a);
  a.click();
  a.remove();
});

// initial render
safeRender();

</script>
</body>
            </html>
