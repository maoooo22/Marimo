<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pencari Ayat Al-Qur'an — Fuzzy Search</title>
  <style>
    :root{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{max-width:1000px;margin:28px auto;padding:20px;background:#f5f7fb;color:#111}
    header{display:flex;align-items:center;gap:12px}
    h1{margin:0;font-size:20px}
    .card{background:#fff;padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(10,10,30,0.06)}
    .controls{display:flex;gap:8px;align-items:center;margin:12px 0}
    input[type=text]{flex:1;padding:10px;border-radius:8px;border:1px solid #e3e6ee}
    button{padding:10px 14px;border-radius:8px;border:0;background:#0b78f0;color:#fff;cursor:pointer}
    button.ghost{background:#e7eefc;color:#0b78f0}
    .small{font-size:13px;color:#666}
    .meta{font-size:13px;color:#333;margin-bottom:6px;display:flex;justify-content:space-between}
    .result{padding:12px;border-radius:8px;background:#fff;margin-top:10px;border:1px solid #eef2ff}
    .arab{font-family:'Scheherazade New','Noto Naskh Arabic',serif;font-size:20px;direction:rtl;margin:8px 0}
    .translation{font-size:14px;color:#333}
    .score{font-size:12px;color:#777}
    .hint{font-size:13px;color:#666;margin-top:8px}
    .badge{display:inline-block;padding:4px 8px;background:#f1f5f9;border-radius:999px;font-size:12px;color:#334155}
    .highlight{background: #fff3bf; border-radius:3px; padding:0 2px}
    footer{margin-top:18px;font-size:13px;color:#666}
    .flex{display:flex;gap:8px;align-items:center}
    label{font-size:13px;color:#444}
  </style>
</head>
<body>
  <div class="card">
    <header>
      <h1>Pencari Ayat Al-Qur'an — Fuzzy</h1>
      <div class="small" style="margin-left:auto">Ready to find that half-remembered ayah.</div>
    </header>

    <p class="small">Ketik potongan ayat (bisa Arab, transliterasi, atau terjemahan). Sistem pakai fuzzy search (Fuse.js) supaya tetap ketemu walau typo.</p>

    <div class="controls">
      <input id="q" type="text" placeholder="Contoh: innal abroro nafi na'im  — atau ketik terjemahan: 'orang-orang yang beriman' " />
      <button id="search">Cari</button>
      <button id="clearCache" class="ghost">Clear cache</button>
    </div>

    <div class="flex" style="margin-bottom:8px">
      <label><input type="checkbox" id="chkArabic" checked /> Arab</label>
      <label><input type="checkbox" id="chkTrans" checked /> Terjemahan</label>
      <div style="margin-left:auto" class="small">Threshold: <input id="threshold" type="range" min="0" max="1" step="0.01" value="0.45"/></div>
    </div>

    <div id="status" class="hint">Status: belum memuat data. Jika ini pertama kali, akan mengunduh seluruh teks — sabar sebentar.</div>
    <div id="results"></div>
    <footer>Limit hasil: <span id="limitBadge" class="badge">50</span>. Gunakan slider threshold untuk hasil lebih longgar/ketat.</footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
  <script>
    // CONFIG
    const API_URL = '/api/quran'; // harus tersedia di server (Vercel)
    const STORAGE_KEY = 'alquran_cache_v2';
    const RESULT_LIMIT = 50;

    // UI
    const qEl = document.getElementById('q');
    const searchBtn = document.getElementById('search');
    const clearCacheBtn = document.getElementById('clearCache');
    const statusEl = document.getElementById('status');
    const resultsEl = document.getElementById('results');
    const chkArabic = document.getElementById('chkArabic');
    const chkTrans = document.getElementById('chkTrans');
    const thresholdEl = document.getElementById('threshold');
    const limitBadge = document.getElementById('limitBadge');

    let verses = []; // {surah, surahNumber, ayahNumber, text, translation}
    let fuse = null;

    function escapeHtml(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    // highlight matched ranges (uses Fuse matches)
    function highlightText(text, matchesForKey) {
      if(!matchesForKey || matchesForKey.length===0) return escapeHtml(text);
      // matchesForKey: array of {indices: [[start,end], ...]}
      // We'll merge indices then wrap with span
      const indices = [].concat(...matchesForKey.map(m => m.indices || []));
      if(indices.length===0) return escapeHtml(text);
      indices.sort((a,b)=>a[0]-b[0]);
      // merge
      const merged = [];
      let cur = indices[0].slice();
      for(let i=1;i<indices.length;i++){
        const nxt = indices[i];
        if(nxt[0] <= cur[1]+1) cur[1] = Math.max(cur[1], nxt[1]);
        else { merged.push(cur); cur = nxt.slice(); }
      }
      merged.push(cur);
      // build string
      let out = '';
      let last = 0;
      for(const [s,e] of merged){
        out += escapeHtml(text.slice(last, s));
        out += '<span class="highlight">'+escapeHtml(text.slice(s, e+1))+'</span>';
        last = e+1;
      }
      out += escapeHtml(text.slice(last));
      return out;
    }

    // Flatten structure from gading.dev style or many others
    function flattenGading(json){
      // Expected shape: json.data -> array of surahs, each has verses array
      const out = [];
      const data = json?.data || json;
      if(!Array.isArray(data)) return out;
      data.forEach(surah => {
        const surahName = (surah.name && (surah.name.transliteration?.id || surah.name.short || surah.name.long || surah.name)) || ('Surah '+(surah.number||'?'));
        const sNum = surah.number || null;
        const versesArr = surah.verses || surah.ayahs || surah.verses_list || [];
        if(Array.isArray(versesArr)){
          versesArr.forEach(v => {
            const text = v.text?.arab || v.text || v.ar || v.arab || '';
            // translation might be v.translation?.id or v.translation (string)
            const translation = (v.translation && (typeof v.translation === 'string' ? v.translation : (v.translation.id || v.translation.en || ''))) || '';
            const ayahNo = v.number?.inSurah || v.number?.inSurah || v.number || v.numberInSurah || v.numberInSurah || (v.number && v.number.inSurah) || null;
            out.push({
              surah: surahName,
              surahNumber: sNum,
              ayahNumber: ayahNo || v.number?.inSurah || v.number || v.numberInSurah || null,
              text: text,
              translation: translation
            });
          });
        }
      });
      return out;
    }

    async function loadData() {
      statusEl.textContent = 'Status: memeriksa cache...';
      const cached = localStorage.getItem(STORAGE_KEY);
      if(cached){
        try {
          verses = JSON.parse(cached);
          statusEl.textContent = `Status: data dimuat dari cache (${verses.length} ayat).`;
          buildFuse();
          return;
        } catch(e) {
          console.warn('cache parse error', e);
          localStorage.removeItem(STORAGE_KEY);
        }
      }

      statusEl.textContent = 'Status: mengunduh data dari server...';
      try {
        const resp = await fetch(API_URL);
        if(!resp.ok) throw new Error('Upstream fetch gagal: '+resp.status);
        const json = await resp.json();
        // Try flattening; adapt if upstream berbeda.
        verses = flattenGading(json);
        if(verses.length === 0) {
          // try some fallback patterns if upstream returned other shape
          // naive fallback: find any array of objects with text property
          const fallback = [];
          function recurse(obj) {
            if(!obj || typeof obj !== 'object') return;
            for(const k of Object.keys(obj)) {
              const v = obj[k];
              if(Array.isArray(v)) {
                if(v.length && v[0] && (v[0].text || v[0].arab || v[0].translation)) {
                  v.forEach(item => {
                    fallback.push({
                      surah: item.surah || item.chapter || item.surahName || 'unknown',
                      surahNumber: item.surahNumber || item.chapterNumber || null,
                      ayahNumber: item.number || item.ayah || item.ayat || null,
                      text: item.text || item.arab || '',
                      translation: item.translation || ''
                    });
                  });
                } else v.forEach(item => recurse(item));
              } else if(typeof v === 'object') recurse(v);
            }
          }
          recurse(json);
          if(fallback.length) verses = fallback;
        }

        if(verses.length === 0) throw new Error('Tidak bisa parse struktur JSON dari API. Cek API atau gunakan endpoint lain.');
        localStorage.setItem(STORAGE_KEY, JSON.stringify(verses));
        statusEl.textContent = `Status: data berhasil di-download dan disimpan cache (${verses.length} ayat).`;
        buildFuse();
      } catch(err) {
        console.error(err);
        statusEl.textContent = 'Status: gagal mengambil data — ' + err.message;
      }
    }

    function buildFuse() {
      const keys = [];
      if(chkArabic.checked) keys.push({ name: 'text', weight: 0.7 });
      if(chkTrans.checked) keys.push({ name: 'translation', weight: 0.3 });
      if(keys.length === 0) {
        statusEl.textContent = 'Status: pilih minimal salah satu sumber pencarian (Arab/terjemahan).';
        return;
      }

      const options = {
        includeScore: true,
        includeMatches: true,
        threshold: parseFloat(thresholdEl.value),
        keys: keys.map(k=>k.name)
      };
      fuse = new Fuse(verses, options);
      statusEl.textContent = `Status: Fuse siap (threshold ${options.threshold}).`;
    }

    function renderResults(results) {
      resultsEl.innerHTML = '';
      if(!results || results.length===0) {
        resultsEl.innerHTML = '<div class="hint">Tidak ada hasil.</div>';
        return;
      }

      const limited = results.slice(0, RESULT_LIMIT);
      limited.forEach(r => {
        const v = r.item;
        const score = r.score != null ? (Math.round(r.score * 1000)/1000) : '';
        // find matches grouped by key
        const matches = (r.matches || []).reduce((acc, m) => {
          if(!acc[m.key]) acc[m.key] = [];
          acc[m.key].push(m);
          return acc;
        }, {});
        const arabHTML = highlightText(v.text || '', matches.text);
        const transHTML = highlightText(v.translation || '', matches.translation);

        const div = document.createElement('div');
        div.className = 'result';
        div.innerHTML = `
          <div class="meta">
            <div><strong>${escapeHtml(v.surah || 'Surah?')}</strong> — Ayat <strong>${escapeHtml(String(v.ayahNumber || '?'))}</strong></div>
            <div class="score">score ${score}</div>
          </div>
          <div class="arab">${arabHTML}</div>
          <div class="translation">${transHTML}</div>
        `;
        resultsEl.appendChild(div);
      });

      statusEl.textContent = `Status: menampilkan ${limited.length} dari ${results.length} hasil (threshold ${thresholdEl.value}).`;
    }

    async function doSearch() {
      const q = qEl.value.trim();
      if(!q) { statusEl.textContent = 'Status: masukkan query dulu.'; return; }
      if(!verses || verses.length === 0) { statusEl.textContent='Status: data belum siap. Mengunduh...'; await loadData(); }
      if(!fuse) buildFuse();
      if(!fuse) { statusEl.textContent='Status: Fuse belum siap.'; return; }
      statusEl.textContent = 'Status: mencari...';
      const results = fuse.search(q, { limit: 1000 });
      renderResults(results);
    }

    // events
    searchBtn.addEventListener('click', doSearch);
    qEl.addEventListener('keydown', e => { if(e.key === 'Enter') doSearch(); });
    clearCacheBtn.addEventListener('click', () => {
      localStorage.removeItem(STORAGE_KEY);
      verses = []; fuse = null; resultsEl.innerHTML = ''; statusEl.textContent = 'Status: cache dihapus.';
    });
    chkArabic.addEventListener('change', () => { if(verses.length) buildFuse(); });
    chkTrans.addEventListener('change', () => { if(verses.length) buildFuse(); });
    thresholdEl.addEventListener('input', () => { if(verses.length) buildFuse(); });
    limitBadge.textContent = RESULT_LIMIT;

    // boot
    loadData();
  </script>
</body>
</html>
